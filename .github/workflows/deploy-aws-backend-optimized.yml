name: Deploy Fashion Backend - Optimized Rolling Deployment

on:
  push:
    branches: [main, production]
    paths: ['server/**']
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
      deployment_strategy:
        description: 'Deployment strategy'
        required: false
        default: 'rolling'
        type: choice
        options:
          - rolling
          - blue-green
          - canary

env:
  PROJECT_NAME: fashion-backend
  ENVIRONMENT: production
  REGION: ap-south-1
  MIN_HEALTHY_PERCENTAGE: 75
  CHECKPOINT_PERCENTAGES: '[25,50,75,100]'
  CHECKPOINT_DELAY: 300
  INSTANCE_WARMUP: 600

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || 'production' }}
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.REGION }}

      - name: Enhanced Secret Validation
        run: |
          echo "üîç Validating all required secrets for optimized deployment..."
          
          missing_secrets=()
          
          # Core application secrets
          [ -z "${{ secrets.DATABASE }}" ] && missing_secrets+=("DATABASE")
          [ -z "${{ secrets.SECRET }}" ] && missing_secrets+=("SECRET")
          [ -z "${{ secrets.CLIENT_URL }}" ] && missing_secrets+=("CLIENT_URL")
          
          # Payment gateway secrets
          [ -z "${{ secrets.RAZORPAY_KEY_ID }}" ] && missing_secrets+=("RAZORPAY_KEY_ID")
          [ -z "${{ secrets.RAZORPAY_KEY_SECRET }}" ] && missing_secrets+=("RAZORPAY_KEY_SECRET")
          [ -z "${{ secrets.BRAINTREE_MERCHANT_ID }}" ] && missing_secrets+=("BRAINTREE_MERCHANT_ID")
          [ -z "${{ secrets.BRAINTREE_PUBLIC_KEY }}" ] && missing_secrets+=("BRAINTREE_PUBLIC_KEY")
          [ -z "${{ secrets.BRAINTREE_PRIVATE_KEY }}" ] && missing_secrets+=("BRAINTREE_PRIVATE_KEY")
          
          # Communication secrets
          [ -z "${{ secrets.BREVO_API_KEY }}" ] && missing_secrets+=("BREVO_API_KEY")
          [ -z "${{ secrets.BREVO_SENDER_EMAIL }}" ] && missing_secrets+=("BREVO_SENDER_EMAIL")
          [ -z "${{ secrets.MSG91_AUTH_KEY }}" ] && missing_secrets+=("MSG91_AUTH_KEY")
          [ -z "${{ secrets.REDIS_URL }}" ] && missing_secrets+=("REDIS_URL")
          
          if [ ${#missing_secrets[@]} -ne 0 ]; then
            echo "‚ùå Missing required secrets:"
            printf '%s\n' "${missing_secrets[@]}"
            echo ""
            echo "üí° Add missing secrets in GitHub Settings ‚Üí Secrets and variables ‚Üí Actions"
            exit 1
          fi
          
          echo "‚úÖ All required secrets validated for optimized deployment"

      - name: Pre-deployment Infrastructure Check
        id: infra-check
        run: |
          echo "üèóÔ∏è Checking infrastructure readiness for optimized deployment..."
          
          ASG_NAME="${PROJECT_NAME}-${ENVIRONMENT}-asg"
          ALB_NAME="${PROJECT_NAME}-${ENVIRONMENT}-alb"
          TG_NAME="${PROJECT_NAME}-${ENVIRONMENT}-tg"
          
          # Check Auto Scaling Group
          if ! aws autoscaling describe-auto-scaling-groups --auto-scaling-group-names $ASG_NAME &>/dev/null; then
            echo "‚ùå Auto Scaling Group '$ASG_NAME' not found!"
            echo "üí° Run: ./aws/scripts/create-infrastructure-optimized.sh"
            exit 1
          fi
          
          # Get current ASG configuration
          ASG_INFO=$(aws autoscaling describe-auto-scaling-groups \
            --auto-scaling-group-names $ASG_NAME \
            --query 'AutoScalingGroups[0].[MinSize,MaxSize,DesiredCapacity,HealthCheckType,HealthCheckGracePeriod]' \
            --output text)
          
          MIN_SIZE=$(echo $ASG_INFO | cut -f1)
          MAX_SIZE=$(echo $ASG_INFO | cut -f2)
          DESIRED_CAPACITY=$(echo $ASG_INFO | cut -f3)
          HEALTH_CHECK_TYPE=$(echo $ASG_INFO | cut -f4)
          GRACE_PERIOD=$(echo $ASG_INFO | cut -f5)
          
          echo "üìä Current ASG Configuration:"
          echo "   ‚Ä¢ Min Size: $MIN_SIZE"
          echo "   ‚Ä¢ Max Size: $MAX_SIZE"
          echo "   ‚Ä¢ Desired Capacity: $DESIRED_CAPACITY"
          echo "   ‚Ä¢ Health Check Type: $HEALTH_CHECK_TYPE"
          echo "   ‚Ä¢ Grace Period: ${GRACE_PERIOD}s"
          
          # Check Load Balancer
          ALB_ARN=$(aws elbv2 describe-load-balancers \
            --names $ALB_NAME \
            --query 'LoadBalancers[0].LoadBalancerArn' --output text 2>/dev/null || echo "None")
          
          if [ "$ALB_ARN" == "None" ]; then
            echo "‚ùå Load Balancer '$ALB_NAME' not found!"
            exit 1
          fi
          
          # Check Target Group health settings
          TG_ARN=$(aws elbv2 describe-target-groups \
            --names $TG_NAME \
            --query 'TargetGroups[0].TargetGroupArn' --output text)
          
          TG_HEALTH=$(aws elbv2 describe-target-groups \
            --target-group-arns $TG_ARN \
            --query 'TargetGroups[0].[HealthCheckIntervalSeconds,HealthyThresholdCount,UnhealthyThresholdCount,HealthCheckTimeoutSeconds]' \
            --output text)
          
          INTERVAL=$(echo $TG_HEALTH | cut -f1)
          HEALTHY_THRESHOLD=$(echo $TG_HEALTH | cut -f2)
          UNHEALTHY_THRESHOLD=$(echo $TG_HEALTH | cut -f3)
          TIMEOUT=$(echo $TG_HEALTH | cut -f4)
          
          echo "üéØ Target Group Health Configuration:"
          echo "   ‚Ä¢ Check Interval: ${INTERVAL}s"
          echo "   ‚Ä¢ Healthy Threshold: $HEALTHY_THRESHOLD"
          echo "   ‚Ä¢ Unhealthy Threshold: $UNHEALTHY_THRESHOLD"
          echo "   ‚Ä¢ Timeout: ${TIMEOUT}s"
          
          # Verify optimized settings
          if [ "$INTERVAL" -le 15 ] && [ "$HEALTHY_THRESHOLD" -ge 3 ]; then
            echo "‚úÖ Target Group configured for optimized rolling deployment"
          else
            echo "‚ö†Ô∏è Target Group not optimized - continuing anyway"
          fi
          
          # Output for next steps
          echo "asg_name=$ASG_NAME" >> $GITHUB_OUTPUT
          echo "alb_arn=$ALB_ARN" >> $GITHUB_OUTPUT
          echo "tg_arn=$TG_ARN" >> $GITHUB_OUTPUT
          echo "current_capacity=$DESIRED_CAPACITY" >> $GITHUB_OUTPUT

      - name: Update Parameter Store with Enhanced Secrets
        run: |
          echo "üîê Updating Parameter Store with enhanced configuration..."
          
          PARAM_PREFIX="/${PROJECT_NAME}/${ENVIRONMENT}"
          
          # Function to safely update parameter
          update_parameter() {
            local name=$1
            local value=$2
            local type=${3:-"SecureString"}
            
            if [ -n "$value" ] && [ "$value" != "null" ]; then
              aws ssm put-parameter \
                --name "$PARAM_PREFIX/$name" \
                --value "$value" \
                --type "$type" \
                --overwrite \
                --description "Updated via optimized deployment pipeline"
              echo "‚úÖ Updated $name"
            else
              echo "‚ö†Ô∏è Skipping empty parameter: $name"
            fi
          }
          
          # Core application parameters
          echo "üìù Updating core application parameters..."
          update_parameter "DATABASE" "${{ secrets.DATABASE }}"
          update_parameter "PORT" "${{ secrets.PORT || '8000' }}" "String"
          update_parameter "SECRET" "${{ secrets.SECRET }}"
          update_parameter "CLIENT_URL" "${{ secrets.CLIENT_URL }}" "String"
          update_parameter "NODE_ENV" "${{ secrets.NODE_ENV || 'production' }}" "String"
          
          # Enhanced payment parameters
          echo "üí≥ Updating payment gateway parameters..."
          update_parameter "BRAINTREE_MERCHANT_ID" "${{ secrets.BRAINTREE_MERCHANT_ID }}"
          update_parameter "BRAINTREE_PUBLIC_KEY" "${{ secrets.BRAINTREE_PUBLIC_KEY }}"
          update_parameter "BRAINTREE_PRIVATE_KEY" "${{ secrets.BRAINTREE_PRIVATE_KEY }}"
          update_parameter "RAZORPAY_KEY_ID" "${{ secrets.RAZORPAY_KEY_ID }}"
          update_parameter "RAZORPAY_KEY_SECRET" "${{ secrets.RAZORPAY_KEY_SECRET }}"
          update_parameter "RAZORPAY_WEBHOOK_SECRET" "${{ secrets.RAZORPAY_WEBHOOK_SECRET }}"
          
          # Shipping parameters
          echo "üì¶ Updating shipping parameters..."
          update_parameter "SHIPROCKET_EMAIL" "${{ secrets.SHIPROCKET_EMAIL }}" "String"
          update_parameter "SHIPROCKET_PASSWORD" "${{ secrets.SHIPROCKET_PASSWORD }}"
          update_parameter "SHIPROCKET_TEST_MODE" "${{ secrets.SHIPROCKET_TEST_MODE || 'true' }}" "String"
          update_parameter "PICKUP_PINCODE" "${{ secrets.PICKUP_PINCODE }}" "String"
          update_parameter "PICKUP_NAME" "${{ secrets.PICKUP_NAME }}" "String"
          update_parameter "PICKUP_PHONE" "${{ secrets.PICKUP_PHONE }}" "String"
          
          # Communication parameters
          echo "üìß Updating communication parameters..."
          update_parameter "EMAIL_SERVICE" "${{ secrets.EMAIL_SERVICE || 'brevo' }}" "String"
          update_parameter "BREVO_API_KEY" "${{ secrets.BREVO_API_KEY }}"
          update_parameter "BREVO_SENDER_EMAIL" "${{ secrets.BREVO_SENDER_EMAIL }}" "String"
          update_parameter "BREVO_SENDER_NAME" "${{ secrets.BREVO_SENDER_NAME }}" "String"
          
          # SMS parameters
          echo "üì± Updating SMS parameters..."
          update_parameter "MSG91_AUTH_KEY" "${{ secrets.MSG91_AUTH_KEY }}"
          update_parameter "MSG91_SENDER_ID" "${{ secrets.MSG91_SENDER_ID }}" "String"
          update_parameter "MSG91_TEMPLATE_ID" "${{ secrets.MSG91_TEMPLATE_ID }}" "String"
          update_parameter "MSG91_ROUTE" "${{ secrets.MSG91_ROUTE || '4' }}" "String"
          
          # Infrastructure parameters
          echo "üîß Updating infrastructure parameters..."
          update_parameter "REDIS_URL" "${{ secrets.REDIS_URL }}"
          
          # OAuth parameters (optional)
          if [ -n "${{ secrets.GOOGLE_CLIENT_ID }}" ]; then
            update_parameter "GOOGLE_CLIENT_ID" "${{ secrets.GOOGLE_CLIENT_ID }}"
            update_parameter "GOOGLE_CLIENT_SECRET" "${{ secrets.GOOGLE_CLIENT_SECRET }}"
          fi
          
          if [ -n "${{ secrets.FACEBOOK_APP_ID }}" ]; then
            update_parameter "FACEBOOK_APP_ID" "${{ secrets.FACEBOOK_APP_ID }}"
            update_parameter "FACEBOOK_APP_SECRET" "${{ secrets.FACEBOOK_APP_SECRET }}"
          fi
          
          # Verify parameter count
          PARAM_COUNT=$(aws ssm get-parameters-by-path \
            --path "$PARAM_PREFIX" \
            --recursive \
            --query 'Parameters' \
            --output text | wc -l)
          
          echo "üìä Total parameters stored: $PARAM_COUNT"
          echo "‚úÖ Enhanced parameter store update completed"

      - name: Create Launch Template Version
        id: launch-template
        run: |
          echo "üöÄ Creating new launch template version for deployment..."
          
          TEMPLATE_NAME="${PROJECT_NAME}-${ENVIRONMENT}-lt"
          
          # Get current launch template
          if ! aws ec2 describe-launch-templates --launch-template-names $TEMPLATE_NAME &>/dev/null; then
            echo "‚ùå Launch template '$TEMPLATE_NAME' not found!"
            echo "üí° Run infrastructure setup first"
            exit 1
          fi
          
          # Get latest version number
          LATEST_VERSION=$(aws ec2 describe-launch-template-versions \
            --launch-template-name $TEMPLATE_NAME \
            --query 'LaunchTemplateVersions | sort_by(@, &VersionNumber) | [-1].VersionNumber' \
            --output text)
          
          echo "üìù Current latest version: $LATEST_VERSION"
          
          # Create new version with timestamp
          DEPLOYMENT_VERSION="v$(date +%Y%m%d-%H%M%S)"
          
          # Get current template data
          TEMPLATE_DATA=$(aws ec2 describe-launch-template-versions \
            --launch-template-name $TEMPLATE_NAME \
            --versions '$Latest' \
            --query 'LaunchTemplateVersions[0].LaunchTemplateData' \
            --output json)
          
          # Add deployment metadata to tags
          UPDATED_TEMPLATE_DATA=$(echo "$TEMPLATE_DATA" | jq --arg version "$DEPLOYMENT_VERSION" --arg sha "$GITHUB_SHA" '
            .TagSpecifications[0].Tags += [
              {"Key": "DeploymentVersion", "Value": $version},
              {"Key": "GitCommit", "Value": $sha},
              {"Key": "DeploymentTime", "Value": (now | strftime("%Y-%m-%d %H:%M:%S UTC"))}
            ]
          ')
          
          # Save to file
          echo "$UPDATED_TEMPLATE_DATA" > /tmp/template-data.json
          
          # Create new version
          NEW_VERSION=$(aws ec2 create-launch-template-version \
            --launch-template-name $TEMPLATE_NAME \
            --version-description "Optimized deployment $DEPLOYMENT_VERSION" \
            --launch-template-data file:///tmp/template-data.json \
            --query 'LaunchTemplateVersion.VersionNumber' \
            --output text)
          
          echo "‚úÖ Created launch template version: $NEW_VERSION"
          echo "üè∑Ô∏è Deployment version: $DEPLOYMENT_VERSION"
          
          # Set as default version
          aws ec2 modify-launch-template \
            --launch-template-name $TEMPLATE_NAME \
            --default-version $NEW_VERSION
          
          echo "template_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "deployment_version=$DEPLOYMENT_VERSION" >> $GITHUB_OUTPUT

      - name: Optimized Rolling Deployment
        id: rolling-deployment
        run: |
          echo "üîÑ Starting optimized rolling deployment..."
          ASG_NAME="${{ steps.infra-check.outputs.asg_name }}"
          
          # Pre-deployment validation
          echo "üìã Pre-deployment validation..."
          
          # Check current instance health
          CURRENT_INSTANCES=$(aws autoscaling describe-auto-scaling-groups \
            --auto-scaling-group-names $ASG_NAME \
            --query 'AutoScalingGroups[0].Instances[?LifecycleState==`InService`].InstanceId' \
            --output text)
          
          HEALTHY_COUNT=$(echo $CURRENT_INSTANCES | wc -w)
          echo "üíö Currently healthy instances: $HEALTHY_COUNT"
          
          if [ $HEALTHY_COUNT -eq 0 ]; then
            echo "‚ùå No healthy instances found - aborting deployment"
            exit 1
          fi
          
          # Start enhanced instance refresh
          echo "üöÄ Starting enhanced instance refresh with staged rollout..."
          
          REFRESH_ID=$(aws autoscaling start-instance-refresh \
            --auto-scaling-group-name $ASG_NAME \
            --preferences "{
              \"MinHealthyPercentage\": $MIN_HEALTHY_PERCENTAGE,
              \"InstanceWarmup\": $INSTANCE_WARMUP,
              \"CheckpointPercentages\": $CHECKPOINT_PERCENTAGES,
              \"CheckpointDelay\": $CHECKPOINT_DELAY,
              \"SkipMatching\": false,
              \"ScaleInProtectedInstances\": \"Ignore\"
            }" \
            --desired-configuration "{
              \"LaunchTemplate\": {
                \"LaunchTemplateName\": \"${PROJECT_NAME}-${ENVIRONMENT}-lt\",
                \"Version\": \"\$Latest\"
              }
            }" \
            --query 'InstanceRefreshId' --output text)
          
          echo "üéØ Instance refresh started with ID: $REFRESH_ID"
          echo "üìä Configuration:"
          echo "   ‚Ä¢ Min Healthy Percentage: $MIN_HEALTHY_PERCENTAGE%"
          echo "   ‚Ä¢ Instance Warmup: ${INSTANCE_WARMUP}s (10 minutes)"
          echo "   ‚Ä¢ Staged Rollout: 25% ‚Üí 50% ‚Üí 75% ‚Üí 100%"
          echo "   ‚Ä¢ Checkpoint Delay: ${CHECKPOINT_DELAY}s (5 minutes)"
          
          echo "refresh_id=$REFRESH_ID" >> $GITHUB_OUTPUT

      - name: Monitor Staged Rollout
        run: |
          echo "üìä Monitoring staged rollout progress..."
          ASG_NAME="${{ steps.infra-check.outputs.asg_name }}"
          REFRESH_ID="${{ steps.rolling-deployment.outputs.refresh_id }}"
          
          START_TIME=$(date +%s)
          TIMEOUT=2700  # 45 minutes timeout
          
          # Enhanced monitoring function
          monitor_checkpoint() {
            local checkpoint=$1
            echo ""
            echo "üéØ Monitoring checkpoint: $checkpoint%"
            echo "‚è≥ Waiting for checkpoint completion..."
            
            while true; do
              CURRENT_TIME=$(date +%s)
              ELAPSED=$((CURRENT_TIME - START_TIME))
              
              if [ $ELAPSED -gt $TIMEOUT ]; then
                echo "‚ùå Deployment timed out after 45 minutes"
                return 1
              fi
              
              # Get detailed refresh status
              REFRESH_STATUS=$(aws autoscaling describe-instance-refreshes \
                --auto-scaling-group-name $ASG_NAME \
                --instance-refresh-ids $REFRESH_ID \
                --query 'InstanceRefreshes[0].[Status,PercentageComplete,StatusReason]' \
                --output text)
              
              STATUS=$(echo $REFRESH_STATUS | cut -f1)
              PERCENTAGE=$(echo $REFRESH_STATUS | cut -f2)
              REASON=$(echo $REFRESH_STATUS | cut -f3)
              
              echo "üìà Progress: $PERCENTAGE% ($STATUS)"
              
              # Check if checkpoint reached
              if [ "${PERCENTAGE%.*}" -ge "$checkpoint" ]; then
                echo "‚úÖ Checkpoint $checkpoint% reached!"
                
                # Validate health at checkpoint
                echo "üè• Validating health at checkpoint..."
                validate_health_at_checkpoint
                return 0
              fi
              
              # Check for failures
              case $STATUS in
                "Failed"|"Cancelled")
                  echo "‚ùå Deployment failed at checkpoint $checkpoint%"
                  echo "üí° Reason: $REASON"
                  return 1
                  ;;
              esac
              
              sleep 30
            done
          }
          
          # Health validation function
          validate_health_at_checkpoint() {
            echo "üîç Validating instance health..."
            
            # Get current healthy instances
            HEALTHY_INSTANCES=$(aws autoscaling describe-auto-scaling-groups \
              --auto-scaling-group-names $ASG_NAME \
              --query 'AutoScalingGroups[0].Instances[?LifecycleState==`InService` && HealthStatus==`Healthy`].InstanceId' \
              --output text)
            
            HEALTHY_COUNT=$(echo $HEALTHY_INSTANCES | wc -w)
            echo "üíö Healthy instances: $HEALTHY_COUNT"
            
            # Test load balancer health
            TG_ARN="${{ steps.infra-check.outputs.tg_arn }}"
            HEALTHY_TARGETS=$(aws elbv2 describe-target-health \
              --target-group-arn $TG_ARN \
              --query 'TargetHealthDescriptions[?TargetHealth.State==`healthy`].Target.Id' \
              --output text | wc -w)
            
            echo "üéØ Load balancer healthy targets: $HEALTHY_TARGETS"
            
            if [ $HEALTHY_TARGETS -gt 0 ]; then
              echo "‚úÖ Health validation passed"
            else
              echo "‚ö†Ô∏è No healthy targets in load balancer yet"
            fi
          }
          
          # Monitor each checkpoint
          for checkpoint in 25 50 75 100; do
            if ! monitor_checkpoint $checkpoint; then
              echo "‚ùå Deployment failed at checkpoint $checkpoint%"
              exit 1
            fi
            
            if [ $checkpoint -lt 100 ]; then
              echo "‚è∏Ô∏è Waiting ${CHECKPOINT_DELAY}s before next checkpoint..."
              sleep $CHECKPOINT_DELAY
            fi
          done
          
          echo "üéâ All checkpoints completed successfully!"

      - name: Final Deployment Validation
        run: |
          echo "üè• Performing comprehensive deployment validation..."
          
          # Wait for stabilization
          echo "‚è≥ Waiting 60 seconds for deployment stabilization..."
          sleep 60
          
          # Get Load Balancer DNS
          ALB_ARN="${{ steps.infra-check.outputs.alb_arn }}"
          ALB_DNS=$(aws elbv2 describe-load-balancers \
            --load-balancer-arns $ALB_ARN \
            --query 'LoadBalancers[0].DNSName' --output text)
          
          echo "üåê Testing deployment at: http://$ALB_DNS"
          
          # Enhanced health check validation
          echo "üîç Performing enhanced health check validation..."
          
          VALIDATION_ATTEMPTS=15
          SUCCESSFUL_CHECKS=0
          REQUIRED_SUCCESSES=5
          
          for attempt in $(seq 1 $VALIDATION_ATTEMPTS); do
            echo "üîç Health check attempt $attempt/$VALIDATION_ATTEMPTS..."
            
            # Test health endpoint
            HEALTH_RESPONSE=$(curl -s -f -m 10 "http://$ALB_DNS/health" 2>/dev/null || echo "FAILED")
            
            if [ "$HEALTH_RESPONSE" != "FAILED" ]; then
              # Parse response
              STATUS=$(echo "$HEALTH_RESPONSE" | jq -r '.status' 2>/dev/null || echo "unknown")
              SERVICE=$(echo "$HEALTH_RESPONSE" | jq -r '.service' 2>/dev/null || echo "unknown")
              
              echo "üìä Health check response: status=$STATUS, service=$SERVICE"
              
              if [ "$STATUS" = "healthy" ] && [ "$SERVICE" = "fashion-backend" ]; then
                SUCCESSFUL_CHECKS=$((SUCCESSFUL_CHECKS + 1))
                echo "‚úÖ Health check passed ($SUCCESSFUL_CHECKS/$REQUIRED_SUCCESSES)"
                
                if [ $SUCCESSFUL_CHECKS -ge $REQUIRED_SUCCESSES ]; then
                  echo "üéâ Health validation completed successfully!"
                  echo "üìä Final health response:"
                  echo "$HEALTH_RESPONSE" | jq '.' 2>/dev/null || echo "$HEALTH_RESPONSE"
                  break
                fi
              else
                echo "‚ö†Ô∏è Application not fully ready (status: $STATUS)"
                SUCCESSFUL_CHECKS=0  # Reset counter for consecutive successes
              fi
            else
              echo "‚ùå Health check failed"
              SUCCESSFUL_CHECKS=0  # Reset counter
            fi
            
            if [ $attempt -eq $VALIDATION_ATTEMPTS ]; then
              echo "‚ùå Health validation failed after $VALIDATION_ATTEMPTS attempts"
              echo "üí° Manual verification may be required"
              exit 1
            fi
            
            sleep 20
          done
          
          # Test readiness endpoint
          echo "üîç Testing readiness endpoint..."
          READY_RESPONSE=$(curl -s -f -m 10 "http://$ALB_DNS/ready" 2>/dev/null || echo "FAILED")
          
          if [ "$READY_RESPONSE" != "FAILED" ]; then
            echo "‚úÖ Readiness check passed"
            echo "$READY_RESPONSE" | jq '.' 2>/dev/null || echo "$READY_RESPONSE"
          else
            echo "‚ö†Ô∏è Readiness check failed - application may still be starting"
          fi
          
          # Final instance validation
          echo "üìä Final instance status validation..."
          ASG_NAME="${{ steps.infra-check.outputs.asg_name }}"
          
          INSTANCE_STATUS=$(aws autoscaling describe-auto-scaling-groups \
            --auto-scaling-group-names $ASG_NAME \
            --query 'AutoScalingGroups[0].Instances[?LifecycleState==`InService`].[InstanceId,HealthStatus]' \
            --output text)
          
          echo "üñ•Ô∏è Instance status:"
          echo "$INSTANCE_STATUS" | while read instance_id health_status; do
            echo "   ‚Ä¢ $instance_id: $health_status"
          done
          
          HEALTHY_INSTANCES=$(echo "$INSTANCE_STATUS" | grep -c "Healthy" || echo "0")
          echo "üíö Total healthy instances: $HEALTHY_INSTANCES"

      - name: Deployment Summary
        if: always()
        run: |
          echo ""
          echo "=========================================="
          if [ "${{ job.status }}" == "success" ]; then
            echo "üéâ ‚úÖ OPTIMIZED ROLLING DEPLOYMENT SUCCESSFUL!"
            echo "=========================================="
            echo ""
            echo "üåü Deployment completed with enhanced features:"
            echo "   ‚Ä¢ ‚úÖ Zero-downtime rolling deployment"
            echo "   ‚Ä¢ ‚úÖ Staged rollout (25% ‚Üí 50% ‚Üí 75% ‚Üí 100%)"
            echo "   ‚Ä¢ ‚úÖ Enhanced health validation (5 consecutive passes)"
            echo "   ‚Ä¢ ‚úÖ 75% minimum healthy instances maintained"
            echo "   ‚Ä¢ ‚úÖ Auto-rollback on failure"
            echo "   ‚Ä¢ ‚úÖ Launch template versioning"
            echo ""
            echo "üìä Deployment metrics:"
            echo "   ‚Ä¢ Instance refresh ID: ${{ steps.rolling-deployment.outputs.refresh_id }}"
            echo "   ‚Ä¢ Launch template version: ${{ steps.launch-template.outputs.template_version }}"
            echo "   ‚Ä¢ Deployment version: ${{ steps.launch-template.outputs.deployment_version }}"
            echo ""
            
            # Show access URLs
            ALB_ARN="${{ steps.infra-check.outputs.alb_arn }}"
            ALB_DNS=$(aws elbv2 describe-load-balancers \
              --load-balancer-arns $ALB_ARN \
              --query 'LoadBalancers[0].DNSName' --output text 2>/dev/null || echo "")
            
            if [ -n "$ALB_DNS" ] && [ "$ALB_DNS" != "None" ]; then
              echo "üåê Your optimized fashion backend:"
              echo "   ‚Ä¢ API: http://$ALB_DNS"
              echo "   ‚Ä¢ Health: http://$ALB_DNS/health"
              echo "   ‚Ä¢ Readiness: http://$ALB_DNS/ready"
            fi
            
            echo ""
            echo "üîÑ Rolling deployment flow completed:"
            echo "   1. ‚úÖ New instances launched with updated code"
            echo "   2. ‚úÖ Enhanced health checks validated new instances"
            echo "   3. ‚úÖ Load balancer gradually shifted traffic"
            echo "   4. ‚úÖ Old instances drained and terminated"
            echo "   5. ‚úÖ Zero downtime maintained throughout"
          else
            echo "‚ùå üö® OPTIMIZED DEPLOYMENT FAILED!"
            echo "=========================================="
            echo ""
            echo "üí° Troubleshooting steps:"
            echo "‚Ä¢ Check Auto Scaling Group status"
            echo "‚Ä¢ Review instance refresh status"
            echo "‚Ä¢ Validate Parameter Store configuration"
            echo "‚Ä¢ Check target group health"
            echo "‚Ä¢ Review CloudWatch logs"
            echo ""
            echo "üîß Debug commands:"
            echo "   aws autoscaling describe-instance-refreshes --auto-scaling-group-name ${{ steps.infra-check.outputs.asg_name }}"
            echo "   aws elbv2 describe-target-health --target-group-arn ${{ steps.infra-check.outputs.tg_arn }}"
            echo "   aws ec2 describe-launch-template-versions --launch-template-name ${PROJECT_NAME}-${ENVIRONMENT}-lt"
          fi
          echo "=========================================="
