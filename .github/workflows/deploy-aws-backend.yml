name: Deploy Fashion Backend to AWS (SSH-Free)

on:
  push:
    branches: [main, production]
    paths: ['server/**']
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || 'production' }}
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ap-south-1

      - name: Validate Required Secrets
        run: |
          echo "üîç Validating required secrets..."
          
          missing_secrets=()
          
          # Check core required secrets
          [ -z "${{ secrets.DATABASE }}" ] && missing_secrets+=("DATABASE")
          [ -z "${{ secrets.SECRET }}" ] && missing_secrets+=("SECRET")
          [ -z "${{ secrets.CLIENT_URL }}" ] && missing_secrets+=("CLIENT_URL")
          [ -z "${{ secrets.RAZORPAY_KEY_ID }}" ] && missing_secrets+=("RAZORPAY_KEY_ID")
          [ -z "${{ secrets.RAZORPAY_KEY_SECRET }}" ] && missing_secrets+=("RAZORPAY_KEY_SECRET")
          [ -z "${{ secrets.BREVO_API_KEY }}" ] && missing_secrets+=("BREVO_API_KEY")
          [ -z "${{ secrets.BREVO_SENDER_EMAIL }}" ] && missing_secrets+=("BREVO_SENDER_EMAIL")
          [ -z "${{ secrets.MSG91_AUTH_KEY }}" ] && missing_secrets+=("MSG91_AUTH_KEY")
          [ -z "${{ secrets.REDIS_URL }}" ] && missing_secrets+=("REDIS_URL")
          
          if [ ${#missing_secrets[@]} -ne 0 ]; then
            echo "‚ùå Missing required secrets:"
            printf '%s\n' "${missing_secrets[@]}"
            echo ""
            echo "üí° Add missing secrets in GitHub Settings ‚Üí Secrets and variables ‚Üí Actions"
            exit 1
          fi
          
          echo "‚úÖ All required secrets validated"

      - name: Find Auto Scaling Group
        id: get-asg
        run: |
          ASG_NAME="fashion-backend-production-asg"
          echo "üîç Finding Auto Scaling Group: $ASG_NAME"
          
          # Check if ASG exists
          if ! aws autoscaling describe-auto-scaling-groups --auto-scaling-group-names $ASG_NAME &>/dev/null; then
            echo "‚ùå Auto Scaling Group '$ASG_NAME' not found!"
            echo "üí° Run infrastructure setup first: ./aws/scripts/create-infrastructure.sh"
            exit 1
          fi
          
          # Get ASG details
          ASG_DETAILS=$(aws autoscaling describe-auto-scaling-groups \
            --auto-scaling-group-names $ASG_NAME \
            --query 'AutoScalingGroups[0].[MinSize,MaxSize,DesiredCapacity]' \
            --output text)
          
          MIN_SIZE=$(echo $ASG_DETAILS | cut -f1)
          MAX_SIZE=$(echo $ASG_DETAILS | cut -f2)
          DESIRED_CAPACITY=$(echo $ASG_DETAILS | cut -f3)
          
          echo "‚úÖ Found ASG: $ASG_NAME"
          echo "üìä Current capacity: Min=$MIN_SIZE, Max=$MAX_SIZE, Desired=$DESIRED_CAPACITY"
          
          echo "asg_name=$ASG_NAME" >> $GITHUB_OUTPUT
          echo "min_size=$MIN_SIZE" >> $GITHUB_OUTPUT
          echo "max_size=$MAX_SIZE" >> $GITHUB_OUTPUT
          echo "desired_capacity=$DESIRED_CAPACITY" >> $GITHUB_OUTPUT

      - name: Update Parameter Store Secrets
        run: |
          echo "üîê Updating Parameter Store with application secrets..."
          
          # Parameter Store path prefix
          PARAM_PREFIX="/fashion-backend/production"
          
          # Core application parameters
          echo "üìù Setting core parameters..."
          aws ssm put-parameter \
            --name "$PARAM_PREFIX/DATABASE" \
            --value "${{ secrets.DATABASE }}" \
            --type "SecureString" \
            --overwrite
          
          aws ssm put-parameter \
            --name "$PARAM_PREFIX/PORT" \
            --value "${{ secrets.PORT }}" \
            --type "String" \
            --overwrite
          
          aws ssm put-parameter \
            --name "$PARAM_PREFIX/SECRET" \
            --value "${{ secrets.SECRET }}" \
            --type "SecureString" \
            --overwrite
          
          aws ssm put-parameter \
            --name "$PARAM_PREFIX/CLIENT_URL" \
            --value "${{ secrets.CLIENT_URL }}" \
            --type "String" \
            --overwrite
          
          # Payment integration parameters
          echo "üí≥ Setting payment parameters..."
          aws ssm put-parameter \
            --name "$PARAM_PREFIX/BRAINTREE_MERCHANT_ID" \
            --value "${{ secrets.BRAINTREE_MERCHANT_ID }}" \
            --type "SecureString" \
            --overwrite
          
          aws ssm put-parameter \
            --name "$PARAM_PREFIX/BRAINTREE_PUBLIC_KEY" \
            --value "${{ secrets.BRAINTREE_PUBLIC_KEY }}" \
            --type "SecureString" \
            --overwrite
          
          aws ssm put-parameter \
            --name "$PARAM_PREFIX/BRAINTREE_PRIVATE_KEY" \
            --value "${{ secrets.BRAINTREE_PRIVATE_KEY }}" \
            --type "SecureString" \
            --overwrite
          
          aws ssm put-parameter \
            --name "$PARAM_PREFIX/RAZORPAY_KEY_ID" \
            --value "${{ secrets.RAZORPAY_KEY_ID }}" \
            --type "SecureString" \
            --overwrite
          
          aws ssm put-parameter \
            --name "$PARAM_PREFIX/RAZORPAY_KEY_SECRET" \
            --value "${{ secrets.RAZORPAY_KEY_SECRET }}" \
            --type "SecureString" \
            --overwrite
          
          if [ -n "${{ secrets.RAZORPAY_WEBHOOK_SECRET }}" ]; then
            aws ssm put-parameter \
              --name "$PARAM_PREFIX/RAZORPAY_WEBHOOK_SECRET" \
              --value "${{ secrets.RAZORPAY_WEBHOOK_SECRET }}" \
              --type "SecureString" \
              --overwrite
          fi
          
          # Shipping parameters
          echo "üì¶ Setting shipping parameters..."
          aws ssm put-parameter \
            --name "$PARAM_PREFIX/SHIPROCKET_EMAIL" \
            --value "${{ secrets.SHIPROCKET_EMAIL }}" \
            --type "String" \
            --overwrite
          
          aws ssm put-parameter \
            --name "$PARAM_PREFIX/SHIPROCKET_PASSWORD" \
            --value "${{ secrets.SHIPROCKET_PASSWORD }}" \
            --type "SecureString" \
            --overwrite
          
          aws ssm put-parameter \
            --name "$PARAM_PREFIX/SHIPROCKET_TEST_MODE" \
            --value "${{ secrets.SHIPROCKET_TEST_MODE }}" \
            --type "String" \
            --overwrite
          
          aws ssm put-parameter \
            --name "$PARAM_PREFIX/PICKUP_PINCODE" \
            --value "${{ secrets.PICKUP_PINCODE }}" \
            --type "String" \
            --overwrite
          
          aws ssm put-parameter \
            --name "$PARAM_PREFIX/PICKUP_NAME" \
            --value "${{ secrets.PICKUP_NAME }}" \
            --type "String" \
            --overwrite
          
          aws ssm put-parameter \
            --name "$PARAM_PREFIX/PICKUP_PHONE" \
            --value "${{ secrets.PICKUP_PHONE }}" \
            --type "String" \
            --overwrite
          
          # Email service parameters
          echo "üìß Setting email parameters..."
          aws ssm put-parameter \
            --name "$PARAM_PREFIX/EMAIL_SERVICE" \
            --value "${{ secrets.EMAIL_SERVICE }}" \
            --type "String" \
            --overwrite
          
          aws ssm put-parameter \
            --name "$PARAM_PREFIX/BREVO_API_KEY" \
            --value "${{ secrets.BREVO_API_KEY }}" \
            --type "SecureString" \
            --overwrite
          
          aws ssm put-parameter \
            --name "$PARAM_PREFIX/BREVO_SENDER_EMAIL" \
            --value "${{ secrets.BREVO_SENDER_EMAIL }}" \
            --type "String" \
            --overwrite
          
          aws ssm put-parameter \
            --name "$PARAM_PREFIX/BREVO_SENDER_NAME" \
            --value "${{ secrets.BREVO_SENDER_NAME }}" \
            --type "String" \
            --overwrite
          
          # OAuth parameters
          echo "üîê Setting OAuth parameters..."
          if [ -n "${{ secrets.GOOGLE_CLIENT_ID }}" ]; then
            aws ssm put-parameter \
              --name "$PARAM_PREFIX/GOOGLE_CLIENT_ID" \
              --value "${{ secrets.GOOGLE_CLIENT_ID }}" \
              --type "SecureString" \
              --overwrite
          fi
          
          if [ -n "${{ secrets.GOOGLE_CLIENT_SECRET }}" ]; then
            aws ssm put-parameter \
              --name "$PARAM_PREFIX/GOOGLE_CLIENT_SECRET" \
              --value "${{ secrets.GOOGLE_CLIENT_SECRET }}" \
              --type "SecureString" \
              --overwrite
          fi
          
          if [ -n "${{ secrets.FACEBOOK_APP_ID }}" ]; then
            aws ssm put-parameter \
              --name "$PARAM_PREFIX/FACEBOOK_APP_ID" \
              --value "${{ secrets.FACEBOOK_APP_ID }}" \
              --type "SecureString" \
              --overwrite
          fi
          
          if [ -n "${{ secrets.FACEBOOK_APP_SECRET }}" ]; then
            aws ssm put-parameter \
              --name "$PARAM_PREFIX/FACEBOOK_APP_SECRET" \
              --value "${{ secrets.FACEBOOK_APP_SECRET }}" \
              --type "SecureString" \
              --overwrite
          fi
          
          # Redis and SMS parameters
          echo "üì± Setting SMS & Redis parameters..."
          aws ssm put-parameter \
            --name "$PARAM_PREFIX/REDIS_URL" \
            --value "${{ secrets.REDIS_URL }}" \
            --type "SecureString" \
            --overwrite
          
          aws ssm put-parameter \
            --name "$PARAM_PREFIX/MSG91_AUTH_KEY" \
            --value "${{ secrets.MSG91_AUTH_KEY }}" \
            --type "SecureString" \
            --overwrite
          
          aws ssm put-parameter \
            --name "$PARAM_PREFIX/MSG91_SENDER_ID" \
            --value "${{ secrets.MSG91_SENDER_ID }}" \
            --type "String" \
            --overwrite
          
          aws ssm put-parameter \
            --name "$PARAM_PREFIX/MSG91_TEMPLATE_ID" \
            --value "${{ secrets.MSG91_TEMPLATE_ID }}" \
            --type "String" \
            --overwrite
          
          aws ssm put-parameter \
            --name "$PARAM_PREFIX/MSG91_ROUTE" \
            --value "${{ secrets.MSG91_ROUTE }}" \
            --type "String" \
            --overwrite
          
          aws ssm put-parameter \
            --name "$PARAM_PREFIX/NODE_ENV" \
            --value "${{ secrets.NODE_ENV }}" \
            --type "String" \
            --overwrite

          aws ssm put-parameter \
            --name "$PARAM_PREFIX/PRODUCTION_BACKEND_URL" \
            --value "${{ secrets.PRODUCTION_BACKEND_URL }}" \
            --type "String" \
            --overwrite

          aws ssm put-parameter \
            --name "$PARAM_PREFIX/PRODUCTION_CLIENT_URL" \
            --value "${{ secrets.PRODUCTION_CLIENT_URL }}" \
            --type "String" \
            --overwrite

          # Telegram
          aws ssm put-parameter \
            --name "$PARAM_PREFIX/TELEGRAM_NOTIFICATIONS_ENABLED" \
            --value "${{ secrets.TELEGRAM_NOTIFICATIONS_ENABLED }}" \
            --type "String" \
            --overwrite

          aws ssm put-parameter \
            --name "$PARAM_PREFIX/TELEGRAM_BOT_TOKEN" \
            --value "${{ secrets.TELEGRAM_BOT_TOKEN }}" \
            --type "String" \
            --overwrite

          aws ssm put-parameter \
            --name "$PARAM_PREFIX/TELEGRAM_ADMIN_CHAT_ID" \
            --value "${{ secrets.TELEGRAM_ADMIN_CHAT_ID }}" \
            --type "String" \
            --overwrite
          aws ssm put-parameter \
            --name "$PARAM_PREFIX/COD_BYPASS_OTP" \
            --value "${{ secrets.COD_BYPASS_OTP }}" \
            --type "String" \
            --overwrite

          aws ssm put-parameter \
            --name "$PARAM_PREFIX/USE_R2" \
            --value "$USE_R2" \
            --type "String" \
            --overwrite
          aws ssm put-parameter \
            --name "$PARAM_PREFIX/R2_ACCOUNT_ID" \  
            --value "$R2_ACCOUNT_ID" \
            --type "String" \
            --overwrite
          aws ssm put-parameter \
            --name "$PARAM_PREFIX/R2_ACCESS_KEY_ID" \
            --value "$R2_ACCESS_KEY_ID" \
            --type "SecureString" \ 
            --overwrite
          aws ssm put-parameter \
            --name "$PARAM_PREFIX/R2_SECRET_ACCESS_KEY" \
            --value "$R2_SECRET_ACCESS_KEY" \
            --type "SecureString" \
            --overwrite
          aws ssm put-parameter \
            --name "$PARAM_PREFIX/R2_BUCKET_NAME" \
            --value "$R2_BUCKET_NAME" \
            --type "String" \
            --overwrite
          aws ssm put-parameter \
            --name "$PARAM_PREFIX/R2_PUBLIC_URL" \
            --value "$R2_PUBLIC_URL" \
            --type "String" \
            --overwrite
          aws ssm put-parameter \
            --name "$PARAM_PREFIX/FACEBOOK_CATALOG_ID" \
            --value "$FACEBOOK_CATALOG_ID" \
            --type "String" \
            --overwrite
          aws ssm put-parameter \
            --name "$PARAM_PREFIX/FACEBOOK_ACCESS_TOKEN" \
            --value "$FACEBOOK_ACCESS_TOKEN" \
            --type "SecureString" \
            --overwrite
          

            
          echo "‚úÖ All parameters updated successfully in Parameter Store"

      - name: Zero-Downtime Instance Refresh
        run: |
          echo "üöÄ ZERO-DOWNTIME DEPLOYMENT STARTING"
          echo "=========================================="
          echo "üéØ Strategy: Blue-Green Auto Scaling Group Refresh"
          echo "üìã Process:"
          echo "   1. Launch new instances with updated code"
          echo "   2. Wait for new instances to become healthy"
          echo "   3. Gradually shift traffic from old to new"
          echo "   4. Terminate old instances only after new ones are ready"
          echo "   5. Maintain 50% healthy capacity throughout"
          echo ""
          
          ASG_NAME="${{ steps.get-asg.outputs.asg_name }}"
          
          # ZERO-DOWNTIME: Enhanced instance refresh configuration
          echo "üîß Configuring zero-downtime rolling deployment..."
          
          # Calculate optimal capacity for zero downtime
          CURRENT_CAPACITY=$(aws autoscaling describe-auto-scaling-groups \
            --auto-scaling-group-names $ASG_NAME \
            --query 'AutoScalingGroups[0].DesiredCapacity' --output text)
          
          echo "üìä Current capacity: $CURRENT_CAPACITY instances"
          echo "üéØ Zero-downtime strategy: Overlapping deployment with traffic shifting"
          
          REFRESH_ID=$(aws autoscaling start-instance-refresh \
            --auto-scaling-group-name $ASG_NAME \
            --strategy Rolling \
            --preferences '{
              "MinHealthyPercentage": 50,
              "InstanceWarmup": 600,
              "CheckpointPercentages": [25, 50, 75, 100],
              "CheckpointDelay": 300,
              "SkipMatching": false,
              "ScaleInProtectedInstances": "Ignore"
            }' \
            --query 'InstanceRefreshId' --output text)
          
          echo "‚úÖ Zero-downtime instance refresh initiated:"
          echo "   üìã Refresh ID: $REFRESH_ID"
          echo "   üõ°Ô∏è MinHealthyPercentage: 50% (allows proper overlap)"
          echo "   ‚è±Ô∏è InstanceWarmup: 10 minutes (thorough app startup)"
          echo "   üéØ Checkpoints: 25%, 50%, 75%, 100% (gradual rollout)"
          echo "   ‚è≥ CheckpointDelay: 5 minutes (traffic validation between stages)"
          echo "   üîÑ Strategy: New instances come up ‚Üí Health checks pass ‚Üí Old instances drain ‚Üí Terminate"
          echo ""
          
          # Enhanced monitoring with detailed progress tracking
          echo "üìä MONITORING ZERO-DOWNTIME DEPLOYMENT PROGRESS"
          echo "==============================================="
          START_TIME=$(date +%s)
          TIMEOUT=2700  # 45 minutes timeout (increased for safety)
          LAST_PERCENTAGE=0
          
          while true; do
            CURRENT_TIME=$(date +%s)
            ELAPSED=$((CURRENT_TIME - START_TIME))
            ELAPSED_MIN=$((ELAPSED / 60))
            
            if [ $ELAPSED -gt $TIMEOUT ]; then
              echo "‚ùå Instance refresh timed out after 45 minutes"
              echo "üí° Check AWS Console for detailed failure information"
              exit 1
            fi
            
            # Get detailed refresh status
            REFRESH_DETAILS=$(aws autoscaling describe-instance-refreshes \
              --auto-scaling-group-name $ASG_NAME \
              --instance-refresh-ids $REFRESH_ID \
              --query 'InstanceRefreshes[0].[Status,PercentageComplete,StatusReason,InstancesToUpdate,SuccessfulInstanceRefreshes]' \
              --output text)
            
            STATUS=$(echo $REFRESH_DETAILS | cut -f1)
            PERCENTAGE=$(echo $REFRESH_DETAILS | cut -f2)
            STATUS_REASON=$(echo $REFRESH_DETAILS | cut -f3)
            INSTANCES_TO_UPDATE=$(echo $REFRESH_DETAILS | cut -f4)
            SUCCESSFUL_REFRESHES=$(echo $REFRESH_DETAILS | cut -f5)
            
            # Show progress only when percentage changes
            if [ "$PERCENTAGE" != "$LAST_PERCENTAGE" ]; then
              echo "‚è≥ [$ELAPSED_MIN min] Progress: $PERCENTAGE% | Status: $STATUS"
              if [ -n "$INSTANCES_TO_UPDATE" ] && [ "$INSTANCES_TO_UPDATE" != "None" ]; then
                echo "   üìà Instances: $SUCCESSFUL_REFRESHES updated, $INSTANCES_TO_UPDATE remaining"
              fi
              LAST_PERCENTAGE=$PERCENTAGE
            fi
            
            # Get current healthy instances count
            HEALTHY_INSTANCES=$(aws autoscaling describe-auto-scaling-groups \
              --auto-scaling-group-names $ASG_NAME \
              --query 'AutoScalingGroups[0].Instances[?LifecycleState==`InService` && HealthStatus==`Healthy`] | length(@)' \
              --output text)
            
            case $STATUS in
              "Successful"|"Successful 100"|"Successful 100 None 0 None")
                echo ""
                echo "üéâ ZERO-DOWNTIME DEPLOYMENT COMPLETED SUCCESSFULLY!"
                echo "=============================================="
                echo "‚úÖ All instances refreshed with new code"
                echo "‚úÖ No service interruption during deployment"
                echo "‚úÖ $HEALTHY_INSTANCES healthy instances running"
                echo "‚ö° Total deployment time: $ELAPSED_MIN minutes"
                break
                ;;
              "Failed"|"Cancelled 50"|"Failed 50"|"Cancelled 100" )
                echo ""
                echo "‚ùå DEPLOYMENT FAILED!"
                echo "==================="
                echo "üí• Status: $STATUS"
                echo "üìù Reason: $STATUS_REASON"
                echo "üîÑ Auto-rollback: Old instances preserved"
                
                # Get failure details for troubleshooting
                echo ""
                echo "üîç Troubleshooting Information:"
                aws autoscaling describe-instance-refreshes \
                  --auto-scaling-group-name $ASG_NAME \
                  --instance-refresh-ids $REFRESH_ID \
                  --query 'InstanceRefreshes[0]' \
                  --output table
                
                exit 1
                ;;
              "InProgress"|"Pending")
                # Continue monitoring (reduced frequency to avoid spam)
                if [ $((ELAPSED % 60)) -eq 0 ]; then  # Show status every minute
                  echo "üîÑ [$ELAPSED_MIN min] Active deployment... $HEALTHY_INSTANCES healthy instances"
                fi
                sleep 30
                ;;
              "Cancelling")
                echo "‚ö†Ô∏è Deployment is being cancelled..."
                sleep 30
                ;;
              *)
                echo "‚ö†Ô∏è Unknown status: $STATUS (continuing to monitor)"
                sleep 30
                ;;
            esac
          done
          
          echo ""
          echo "üéØ DEPLOYMENT SUMMARY:"
          echo "   ‚úÖ Zero-downtime achieved"
          echo "   ‚úÖ Blue-green instance replacement"
          echo "   ‚úÖ Load balancer traffic maintained"
          echo "   ‚úÖ All health checks passed"

      - name: Validate Deployment Health
        run: |
          echo "üè• Validating deployment health..."
          
          # Get Load Balancer DNS
          ALB_DNS=$(aws elbv2 describe-load-balancers \
            --names fashion-backend-production-alb \
            --query 'LoadBalancers[0].DNSName' --output text 2>/dev/null || echo "")
          
          if [ -n "$ALB_DNS" ] && [ "$ALB_DNS" != "None" ]; then
            echo "üåê Testing Load Balancer: http://$ALB_DNS"
            
            # Wait for new instances to be ready
            echo "‚è≥ Waiting 60 seconds for new instances to be ready..."
            sleep 120
            
            # Test load balancer health endpoint
            MAX_ATTEMPTS=10
            for attempt in $(seq 1 $MAX_ATTEMPTS); do
              echo "üîç Health check attempt $attempt/$MAX_ATTEMPTS..."
              
              if curl -f -m 10 -s "http://$ALB_DNS/health" | jq -e '.status' &>/dev/null; then
                echo "‚úÖ Load Balancer health check passed!"
                
                # Get health response for verification
                HEALTH_RESPONSE=$(curl -s "http://$ALB_DNS/health")
                echo "üìä Health check response:"
                echo "$HEALTH_RESPONSE" | jq '.' 2>/dev/null || echo "$HEALTH_RESPONSE"
                
                # Verify it's the actual application by checking for valid health response structure
                if echo "$HEALTH_RESPONSE" | jq -e '.status == "healthy" and .timestamp and .uptime' &>/dev/null; then
                  echo "üéâ Fashion backend application is running!"
                  echo "üåü Deployment successful at: http://$ALB_DNS"
                  
                  # Show deployment info
                  echo ""
                  echo "üìä Application Status:"
                  echo "$HEALTH_RESPONSE" | jq '.'
                  break
                else
                  echo "‚ö†Ô∏è Health check passed but response format unexpected"
                  echo "üìù Response received: $HEALTH_RESPONSE"
                  if [ $attempt -eq $MAX_ATTEMPTS ]; then
                    echo "‚ùå Application not fully validated after $MAX_ATTEMPTS attempts"
                    echo "üí° Application may be running but health endpoint format changed"
                    # Don't fail deployment for response format issues - just warn
                    echo "‚ö†Ô∏è Proceeding with deployment as basic health check passed"
                    break
                  fi
                fi
              else
                if [ $attempt -eq $MAX_ATTEMPTS ]; then
                  echo "‚ùå Load Balancer health check failed after $MAX_ATTEMPTS attempts"
                  echo "üí° Check instance logs and Auto Scaling Group status"
                  exit 1
                else
                  echo "‚ö†Ô∏è Health check failed, retrying in 30 seconds..."
                  sleep 30
                fi
              fi
            done
          else
            echo "‚ö†Ô∏è Load Balancer not found, checking individual instances..."
            
            # Get current instances
            INSTANCES=$(aws autoscaling describe-auto-scaling-groups \
              --auto-scaling-group-names fashion-backend-production-asg \
              --query 'AutoScalingGroups[0].Instances[?LifecycleState==`InService`].InstanceId' \
              --output text)
            
            if [ -z "$INSTANCES" ]; then
              echo "‚ùå No running instances found"
              exit 1
            fi
            
            echo "üîç Testing individual instances: $INSTANCES"
            
            # Test each instance
            for instance_id in $INSTANCES; do
              INSTANCE_IP=$(aws ec2 describe-instances \
                --instance-ids $instance_id \
                --query 'Reservations[0].Instances[0].PublicIpAddress' \
                --output text)
              
              if [ "$INSTANCE_IP" != "None" ] && [ -n "$INSTANCE_IP" ]; then
                echo "üåê Testing instance $instance_id at $INSTANCE_IP:8000"
                
                if curl -f -m 10 -s "http://$INSTANCE_IP:8000/health" &>/dev/null; then
                  echo "‚úÖ Instance $instance_id is healthy"
                else
                  echo "‚ùå Instance $instance_id failed health check"
                fi
              fi
            done
          fi

      - name: Deployment Summary
        if: always()
        run: |
          echo ""
          echo "=========================================="
          if [ "${{ job.status }}" == "success" ]; then
            echo "üéâ ‚úÖ SSH-FREE DEPLOYMENT SUCCESSFUL!"
            echo "=========================================="
            echo ""
            echo "üåê Your fashion e-commerce backend is live!"
            echo "üîß Modern deployment architecture:"
            echo "   ‚Ä¢ ‚úÖ No SSH keys required"
            echo "   ‚Ä¢ ‚úÖ Secure Parameter Store for secrets"
            echo "   ‚Ä¢ ‚úÖ Zero-downtime Auto Scaling Group refresh"
            echo "   ‚Ä¢ ‚úÖ ARM64 Graviton instances for cost optimization"
            echo "   ‚Ä¢ ‚úÖ Auto-deployment on instance startup"
            echo ""
            echo "üìà Infrastructure features:"
            echo "   ‚Ä¢ Load balanced across multiple AZs"
            echo "   ‚Ä¢ Auto scaling based on CPU utilization"
            echo "   ‚Ä¢ Health checks and automated recovery"
            echo "   ‚Ä¢ CloudWatch monitoring and logging"
            echo ""
            
            # Show access URLs
            ALB_DNS=$(aws elbv2 describe-load-balancers \
              --names fashion-backend-production-alb \
              --query 'LoadBalancers[0].DNSName' --output text 2>/dev/null || echo "")
            
            if [ -n "$ALB_DNS" ] && [ "$ALB_DNS" != "None" ]; then
              echo "üåü Access your backend:"
              echo "   ‚Ä¢ API: http://$ALB_DNS"
              echo "   ‚Ä¢ Health: http://$ALB_DNS/health"
            fi
          else
            echo "‚ùå üö® DEPLOYMENT FAILED!"
            echo "=========================================="
            echo ""
            echo "üí° Common troubleshooting steps:"
            echo "‚Ä¢ Check GitHub Secrets are properly configured"
            echo "‚Ä¢ Verify infrastructure exists (run create-infrastructure.sh)"
            echo "‚Ä¢ Check Auto Scaling Group has healthy instances"
            echo "‚Ä¢ Review Parameter Store permissions"
            echo "‚Ä¢ Check CloudWatch logs for application errors"
            echo ""
            echo "üîß Debug commands:"
            echo "   aws autoscaling describe-auto-scaling-groups --auto-scaling-group-names fashion-backend-production-asg"
            echo "   aws elbv2 describe-target-health --target-group-arn <target-group-arn>"
            echo "   aws ssm get-parameters-by-path --path '/fashion-backend/production'"
          fi
          echo "=========================================="
